# ONLYOFFICE 2í¸: Document.key ê´€ë¦¬ì™€ DB ì—°ë™ìœ¼ë¡œ ì‹¤ì „ ì‹œìŠ¤í…œ ë§Œë“¤ê¸°

## ğŸ“„ ì‹œë¦¬ì¦ˆ ì •ë³´

- **1í¸**: ONLYOFFICE ê¸°ë³¸ ì—°ë™ (ìˆ˜ë™ Config, ë¡œì»¬ íŒŒì¼)
- **2í¸**: Document.key ê´€ë¦¬ + DB ì—°ë™ + ê³„ì¸µ ë¶„ë¦¬ â† í˜„ì¬ ê¸€
- **3í¸**: MinIO ì™„ì „ í†µí•© + ë³´ì•ˆ ê°•í™” (ì˜ˆì •)

---

## ğŸ¯ 2í¸ì—ì„œ ë§Œë“¤ ê²ƒ

1í¸ì—ì„œëŠ” ONLYOFFICEë¥¼ ì—°ë™í•˜ëŠ” ìµœì†Œí•œì˜ ì½”ë“œë¥¼ ì‘ì„±í–ˆì§€ë§Œ, ì—¬ëŸ¬ ë¬¸ì œê°€ ìˆì—ˆìŠµë‹ˆë‹¤:

### 1í¸ì˜ ë¬¸ì œì 

```java
// âŒ íŒŒì¼ì‹œìŠ¤í…œ lastModifiedì— ì˜ì¡´
document.put("key", fileName + "_" + file.lastModified());

// âŒ Controllerì—ì„œ Repository ì§ì ‘ ì‚¬ìš© (ê³„ì¸µ ë¶„ë¦¬ ìœ„ë°˜)
private final DocumentRepository documentRepository;

// âŒ ì €ì¥ í›„ key ê°±ì‹  ì•ˆ í•¨ â†’ ìºì‹œëœ ì´ì „ ë²„ì „ ì—´ë¦¼
if (status == 2) {
    documentService.saveFile(fileName, inputStream);
    // key ë³€ê²½ ì—†ìŒ!
}
```

### 2í¸ì—ì„œ í•´ê²°í•  ê²ƒ

âœ… **document.key ì˜¬ë°”ë¥¸ ê´€ë¦¬**: OnlyOffice ê³µì‹ ìŠ¤í™ì— ë§ê²Œ êµ¬í˜„
âœ… **DB ê¸°ë°˜ ë²„ì „ ê´€ë¦¬**: editorVersion í•„ë“œë¡œ ì¶”ì 
âœ… **ê³„ì¸µ ë¶„ë¦¬**: Controller â†’ Service â†’ Repository
âœ… **PostgreSQL + JPA**: ë¬¸ì„œ ë©”íƒ€ë°ì´í„° ì˜êµ¬ ì €ì¥
âœ… **KeyUtils**: 128ì ì œí•œ, íŠ¹ìˆ˜ë¬¸ì ì œê±°
âœ… **Force Save ì²˜ë¦¬**: co-editing ì„¸ì…˜ ìœ ì§€

> **ì£¼ì˜**: MinIOëŠ” ì¸í”„ë¼ë§Œ ì¤€ë¹„í•˜ê³ , ì‹¤ì œ í†µí•©ì€ 3í¸ì—ì„œ ì§„í–‰í•©ë‹ˆë‹¤.

---

## ğŸ“š OnlyOffice document.key ìŠ¤í™ ì´í•´í•˜ê¸°

### Keyì˜ ë‘ ê°€ì§€ ì¢…ë¥˜

| êµ¬ë¶„ | `document.key` | `referenceData.fileKey` |
|------|----------------|-------------------------|
| **ìš©ë„** | í¸ì§‘ ì„¸ì…˜ ì‹ë³„ | íŒŒì¼ ì˜êµ¬ ì‹ë³„ |
| **ë³€ê²½ ì‹œì ** | ì €ì¥í•  ë•Œë§ˆë‹¤ ìƒˆë¡œ ìƒì„± | ë¶ˆë³€ (íŒŒì¼ ìƒì„± ì‹œ 1íšŒ) |
| **ì—­í• ** | ì—ë””í„° ìºì‹œ ê´€ë¦¬, co-editing ì„¸ì…˜ ê³µìœ  | ì™¸ë¶€ ë°ì´í„° ì°¸ì¡° |

### ê³µì‹ ìŠ¤í™ ìš”êµ¬ì‚¬í•­

```
"Every time the document is edited and saved, the key must be generated anew."
```

**ì œì•½ì‚¬í•­:**
- ìµœëŒ€ ê¸¸ì´: **128ì**
- íŠ¹ìˆ˜ë¬¸ì: **ì‚¬ìš© ë¶ˆê°€** (ì˜ë¬¸, ìˆ«ì, `_`, `-` ë§Œ í—ˆìš©)
- ê³ ìœ ì„±: ë™ì¼ Document Serverì— ì—°ê²°ëœ ëª¨ë“  ì„œë¹„ìŠ¤ì—ì„œ ê³ ìœ 

### Callback Statusë³„ key ì²˜ë¦¬

| Status | ì˜ë¯¸ | key ì²˜ë¦¬ |
|--------|------|----------|
| **2** | í¸ì§‘ ì¢…ë£Œ & ì €ì¥ ì™„ë£Œ | âœ… editorVersion ì¦ê°€ |
| **6** | Force Save (ì„¸ì…˜ ì¤‘ ì €ì¥) | âš ï¸ editorVersion **ìœ ì§€** |

**ì™œ Force Saveì—ì„œ keyë¥¼ ìœ ì§€í• ê¹Œ?**

```
User A: key=doc_v3 â”€â”€â–º Force Save â”€â”€â–º key ê·¸ëŒ€ë¡œ ìœ ì§€
User B: key=doc_v3 â”€â”€â–º ê³„ì† co-editing ê°€ëŠ¥

ë§Œì•½ Force Saveì—ì„œ keyë¥¼ ë³€ê²½í•˜ë©´?
â†’ User A: key=doc_v4 (ë³€ê²½ë¨)
â†’ User B: key=doc_v3 (ê¸°ì¡´)
â†’ co-editing ì„¸ì…˜ ê¹¨ì§!
```

---

## ğŸ—ï¸ ì•„í‚¤í…ì²˜

### As-Is (1í¸)

```
Controller â†’ File System (lastModified ê¸°ë°˜ key)
```

### To-Be (2í¸)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Controller  â”‚  HTTP ìš”ì²­/ì‘ë‹µë§Œ ì²˜ë¦¬
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Service    â”‚  ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (key ìƒì„±, ë²„ì „ ê´€ë¦¬)
â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
   â”‚       â”‚
   â”‚       â””â”€â”€â–º Repository â†’ PostgreSQL
   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º File System (storage/)
```

---

## ğŸ’» Part 1: Infrastructure Setup

### docker-compose.yml

```yaml
services:
  postgres:
    image: postgres:16-alpine
    container_name: onlyoffice-postgres
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - ./postgres_data:/var/lib/postgresql/data
    restart: always

  minio:
    image: minio/minio:latest
    container_name: onlyoffice-minio
    ports:
      - "9000:9000"   # API
      - "9001:9001"   # Console
    environment:
      - MINIO_ROOT_USER=${MINIO_ROOT_USER}
      - MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD}
    volumes:
      - ./minio_data:/data
    command: server /data --console-address ":9001"
    restart: always

  onlyoffice-docs:
    image: onlyoffice/documentserver:9.1
    container_name: onlyoffice-docs
    ports:
      - "9980:80"
    environment:
      - JWT_ENABLED=true
      - JWT_SECRET=${JWT_SECRET}
    volumes:
      - ./onlyoffice_data/logs:/var/log/onlyoffice
      - ./onlyoffice_data/data:/var/www/onlyoffice/Data
    restart: always
```

### .env íŒŒì¼

```env
# PostgreSQL
POSTGRES_DB=onlyoffice_demo
POSTGRES_USER=demo
POSTGRES_PASSWORD=your-secure-password-here

# MinIO (3í¸ì—ì„œ ì‚¬ìš©)
MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=your-minio-password-here

# ONLYOFFICE JWT (ìµœì†Œ 32ì)
JWT_SECRET=your-secret-key-must-be-at-least-32-characters-long-for-hs256
```

```bash
docker-compose up -d
```

âœ… **ì²´í¬í¬ì¸íŠ¸ 1**: 3ê°œ ì»¨í…Œì´ë„ˆ ì •ìƒ ì‹¤í–‰

---

## ğŸ’» Part 2: Document Entity ì„¤ê³„

### Document.java

```java
@Entity
@Table(name = "documents", indexes = {
    @Index(name = "idx_file_key", columnList = "file_key"),
    @Index(name = "idx_file_name", columnList = "file_name")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Document {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "file_name", nullable = false)
    private String fileName;

    /**
     * ONLYOFFICE referenceDataìš© íŒŒì¼ ì‹ë³„ì (ë¶ˆë³€)
     * ì™¸ë¶€ ë°ì´í„° ì°¸ì¡°, íŒŒì¼ ë§í¬ ë“±ì— ì‚¬ìš©
     */
    @Column(name = "file_key", nullable = false, unique = true)
    private String fileKey;

    /**
     * ONLYOFFICE í¸ì§‘ ì„¸ì…˜ ë²„ì „ (ê°€ë³€)
     * ë¬¸ì„œê°€ í¸ì§‘ë˜ê³  ì €ì¥ë  ë•Œë§ˆë‹¤ ì¦ê°€
     * document.key ìƒì„±ì— ì‚¬ìš©: fileKey + "_v" + editorVersion
     */
    @Column(name = "editor_version", nullable = false)
    @Builder.Default
    private Integer editorVersion = 0;

    @Column(name = "file_type", nullable = false)
    private String fileType;

    @Column(name = "document_type", nullable = false)
    private String documentType;  // word, cell, slide

    @Column(name = "file_size", nullable = false)
    private Long fileSize;

    @Column(name = "storage_path", nullable = false)
    private String storagePath;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    @Builder.Default
    private DocumentStatus status = DocumentStatus.PENDING;

    @Version
    @Builder.Default
    private Integer version = 1;  // ë‚™ê´€ì  ë½

    @CreationTimestamp
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;  // Soft delete

    /**
     * ONLYOFFICE document.key ìƒì„±
     */
    public String getEditorKey() {
        return fileKey + "_v" + editorVersion;
    }

    /**
     * í¸ì§‘ ì„¸ì…˜ ë²„ì „ ì¦ê°€ (status=2ì¼ ë•Œë§Œ)
     */
    public void incrementEditorVersion() {
        this.editorVersion++;
    }
}
```

### DocumentRepository.java

```java
@Repository
public interface DocumentRepository extends JpaRepository<Document, Long> {

    Optional<Document> findByFileNameAndDeletedAtIsNull(String fileName);

    Optional<Document> findByFileKeyAndDeletedAtIsNull(String fileKey);

    List<Document> findAllByDeletedAtIsNull(Sort sort);

    Page<Document> searchByFileName(
        @Param("pattern") String pattern,
        Pageable pageable
    );
}
```

---

## ğŸ’» Part 3: KeyUtils ìœ í‹¸ë¦¬í‹°

### KeyUtils.java

```java
public final class KeyUtils {

    public static final int MAX_KEY_LENGTH = 128;
    private static final Pattern SAFE_CHARS = Pattern.compile("[^a-zA-Z0-9_-]");

    /**
     * ì•ˆì „í•œ document.key ìƒì„±
     */
    public static String generateEditorKey(String fileKey, int version) {
        if (fileKey == null || fileKey.isBlank()) {
            throw new IllegalArgumentException("fileKey cannot be null");
        }

        String raw = fileKey + "_v" + version;
        String safe = sanitize(raw);

        if (safe.length() > MAX_KEY_LENGTH) {
            return generateHashBasedKey(fileKey, version);
        }

        return safe;
    }

    /**
     * íŠ¹ìˆ˜ë¬¸ì ì œê±°
     */
    public static String sanitize(String input) {
        if (input == null) return "";
        return SAFE_CHARS.matcher(input).replaceAll("");
    }

    /**
     * key ìœ íš¨ì„± ê²€ì¦
     */
    public static boolean isValidKey(String key) {
        if (key == null || key.isBlank()) return false;
        if (key.length() > MAX_KEY_LENGTH) return false;
        return !SAFE_CHARS.matcher(key).find();
    }

    /**
     * í•´ì‹œ ê¸°ë°˜ ì¶•ì•½ key ìƒì„± (ê¸´ fileKeyìš©)
     */
    private static String generateHashBasedKey(String fileKey, int version) {
        String hash = DigestUtils.md5DigestAsHex(
            fileKey.getBytes(StandardCharsets.UTF_8)
        ).substring(0, 16);
        return hash + "_v" + version;
    }
}
```

---

## ğŸ’» Part 4: Service ê³„ì¸µ (í•µì‹¬!)

### DocumentService.java

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class DocumentService {

    private final DocumentRepository documentRepository;

    @Value("${storage.path}")
    private String storagePath;

    // ==================== Key ê´€ë¦¬ ====================

    /**
     * ONLYOFFICE document.key ìƒì„±
     * DBì— ë¬¸ì„œê°€ ìˆìœ¼ë©´ DB ê¸°ë°˜, ì—†ìœ¼ë©´ íŒŒì¼ì‹œìŠ¤í…œ fallback
     */
    public String getEditorKey(String fileName) {
        File file = getFile(fileName);

        return documentRepository.findByFileNameAndDeletedAtIsNull(fileName)
            .map(doc -> {
                String key = KeyUtils.generateEditorKey(
                    doc.getFileKey(),
                    doc.getEditorVersion()
                );
                log.debug("Using DB-based key for {}: {}", fileName, key);
                return key;
            })
            .orElseGet(() -> {
                // DBì— ë¬¸ì„œê°€ ì—†ìœ¼ë©´ íŒŒì¼ì‹œìŠ¤í…œ ê¸°ë°˜ fallback
                String fallbackKey = KeyUtils.sanitize(
                    fileName + "_" + file.lastModified()
                );
                log.warn("Document not found in DB, using fallback: {}",
                    fallbackKey);
                return fallbackKey;
            });
    }

    /**
     * í¸ì§‘ ì¢…ë£Œ(status=2) í›„ editorVersion ì¦ê°€
     */
    public void incrementEditorVersion(String fileName) {
        documentRepository.findByFileNameAndDeletedAtIsNull(fileName)
            .ifPresentOrElse(
                doc -> {
                    int oldVersion = doc.getEditorVersion();
                    doc.incrementEditorVersion();
                    documentRepository.save(doc);
                    log.info("Version incremented: {} -> {}",
                        oldVersion, doc.getEditorVersion());
                },
                () -> log.warn("Document not found: {}", fileName)
            );
    }

    /**
     * URLì—ì„œ í¸ì§‘ëœ ë¬¸ì„œ ë‹¤ìš´ë¡œë“œ ë° ì €ì¥
     */
    public void saveDocumentFromUrl(String downloadUrl, String fileName) {
        log.info("Downloading from {} to {}", downloadUrl, fileName);
        try (InputStream in = URI.create(downloadUrl).toURL().openStream()) {
            saveFile(fileName, in);
        } catch (Exception e) {
            throw new RuntimeException("Failed to save document", e);
        }
    }

    // ==================== File I/O ====================

    public File getFile(String fileName) {
        return Paths.get(storagePath).resolve(fileName).toFile();
    }

    public void saveFile(String fileName, InputStream inputStream) {
        try {
            Path dest = Paths.get(storagePath).resolve(fileName);
            Files.copy(inputStream, dest, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            throw new RuntimeException("Failed to store file", e);
        }
    }
}
```

---

## ğŸ’» Part 5: Controller ê³„ì¸µ

### EditorController.java

```java
@Controller
@RequiredArgsConstructor
@Slf4j
public class EditorController {

    private final DocumentService documentService;
    private final JwtManager jwtManager;

    @Value("${onlyoffice.url}")
    private String onlyofficeUrl;

    @GetMapping("/api/config")
    @ResponseBody
    public Map<String, Object> getEditorConfig(
        @RequestParam("fileName") String fileName
    ) {
        String serverUrl = documentService.getServerUrl();
        String fileExtension = getFileExtension(fileName);
        String documentType = getDocumentType(fileExtension);

        // Serviceë¥¼ í†µí•´ editorKey ìƒì„±
        String editorKey = documentService.getEditorKey(fileName);

        Map<String, Object> config = new HashMap<>();
        config.put("documentType", documentType);

        Map<String, Object> document = new HashMap<>();
        document.put("title", fileName);
        document.put("url", serverUrl + "/files/" + fileName);
        document.put("fileType", fileExtension);
        document.put("key", editorKey);  // DB ê¸°ë°˜ key!

        Map<String, Object> editorConfig = new HashMap<>();
        editorConfig.put("mode", "edit");
        editorConfig.put("callbackUrl",
            serverUrl + "/callback?fileName=" + fileName);

        config.put("document", document);
        config.put("editorConfig", editorConfig);

        String token = jwtManager.createToken(config);
        config.put("token", token);

        log.info("Config generated for {}, key: {}", fileName, editorKey);
        return Map.of("config", config, "documentServerUrl", onlyofficeUrl);
    }

    private String getDocumentType(String ext) {
        return switch (ext) {
            case "docx", "doc" -> "word";
            case "xlsx", "xls" -> "cell";
            case "pptx", "ppt" -> "slide";
            default -> "word";
        };
    }
}
```

### CallbackController.java

```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class CallbackController {

    private final DocumentService documentService;
    private final JwtManager jwtManager;
    private final ObjectMapper objectMapper;

    /**
     * ONLYOFFICE Callback ì²˜ë¦¬
     *
     * Status ì½”ë“œ:
     * - 1: í¸ì§‘ ì¤‘
     * - 2: ì €ì¥ ì™„ë£Œ â†’ íŒŒì¼ ì €ì¥ + editorVersion ì¦ê°€
     * - 6: Force Save â†’ íŒŒì¼ë§Œ ì €ì¥ (editorVersion ìœ ì§€)
     */
    @PostMapping("/callback")
    public Map<String, Object> callback(
        HttpServletRequest request,
        @RequestBody String body
    ) {
        try {
            // 1. JWT ê²€ì¦
            String authHeader = request.getHeader("Authorization");
            if (!jwtManager.validateToken(authHeader)) {
                log.error("Invalid JWT token");
                return Map.of("error", 1);
            }

            // 2. íŒŒì‹±
            Map<String, Object> data = objectMapper.readValue(body, Map.class);
            int status = (int) data.get("status");
            String key = (String) data.get("key");
            String fileName = request.getParameter("fileName");

            log.info("Callback: status={}, key={}", status, key);

            // 3. Statusë³„ ì²˜ë¦¬
            switch (status) {
                case 2 -> {
                    // í¸ì§‘ ì¢…ë£Œ & ì €ì¥
                    String url = (String) data.get("url");
                    documentService.saveDocumentFromUrl(url, fileName);
                    documentService.incrementEditorVersion(fileName);
                }
                case 6 -> {
                    // Force Save (co-editing ì„¸ì…˜ ìœ ì§€)
                    String url = (String) data.get("url");
                    documentService.saveDocumentFromUrl(url, fileName);
                    log.info("Force save, version not changed");
                }
            }

            return Map.of("error", 0);

        } catch (Exception e) {
            log.error("Callback error", e);
            return Map.of("error", 1);
        }
    }
}
```

---

## ğŸ’» Part 6: í…ŒìŠ¤íŠ¸

### KeyUtilsTest.java

```java
@DisplayName("KeyUtils")
class KeyUtilsTest {

    @Test
    @DisplayName("ì •ìƒì ì¸ key ìƒì„±")
    void shouldGenerateKey() {
        String key = KeyUtils.generateEditorKey("doc123", 5);
        assertThat(key).isEqualTo("doc123_v5");
    }

    @Test
    @DisplayName("128ì ì œí•œ")
    void shouldLimitTo128Chars() {
        String longKey = "a".repeat(200);
        String result = KeyUtils.generateEditorKey(longKey, 1);
        assertThat(result.length()).isLessThanOrEqualTo(128);
    }

    @Test
    @DisplayName("íŠ¹ìˆ˜ë¬¸ì ì œê±°")
    void shouldRemoveSpecialChars() {
        String result = KeyUtils.sanitize("file@name#.docx");
        assertThat(result).isEqualTo("filenamedocx");
    }

    @Test
    @DisplayName("ìœ íš¨ì„± ê²€ì¦")
    void shouldValidate() {
        assertThat(KeyUtils.isValidKey("doc_v1")).isTrue();
        assertThat(KeyUtils.isValidKey("doc@123")).isFalse();
        assertThat(KeyUtils.isValidKey("a".repeat(129))).isFalse();
    }
}
```

---

## ğŸ¬ ë°ëª¨ ì‹œë‚˜ë¦¬ì˜¤

### 1. ì´ˆê¸° ìƒíƒœ

```
documents í…Œì´ë¸”: ë¹„ì–´ìˆìŒ
storage/: sample.docx ì¡´ì¬
```

### 2. ì²« í¸ì§‘

```bash
# 1. Config ìš”ì²­
curl "http://localhost:8080/api/config?fileName=sample.docx"
{
  "config": {
    "document": {
      "key": "sampledocx_1733712000000"  # Fallback key (DB ì—†ìŒ)
    }
  }
}

# 2. í¸ì§‘ í›„ ì €ì¥ (Callback status=2)
â†’ íŒŒì¼ ì €ì¥ë¨
â†’ editorVersion ì¦ê°€ ì—†ìŒ (DBì— ë ˆì½”ë“œ ì—†ìŒ)
```

### 3. DBì— ë¬¸ì„œ ë“±ë¡ í›„

```sql
INSERT INTO documents (
  file_name, file_key, editor_version, file_type, ...
) VALUES (
  'sample.docx', 'doc_abc123', 0, 'docx', ...
);
```

```bash
# Config ìš”ì²­
curl "http://localhost:8080/api/config?fileName=sample.docx"
{
  "config": {
    "document": {
      "key": "doc_abc123_v0"  # DB ê¸°ë°˜ key!
    }
  }
}

# í¸ì§‘ í›„ ì €ì¥
â†’ editorVersion: 0 â†’ 1

# ë‹¤ìŒ í¸ì§‘
â†’ key: "doc_abc123_v1"
```

---

## ğŸ” í•µì‹¬ ê°œì„  í¬ì¸íŠ¸

### Before (1í¸)

```java
// âŒ Controllerì—ì„œ Repository ì§ì ‘ ì‚¬ìš©
private final DocumentRepository documentRepository;

// âŒ íŒŒì¼ì‹œìŠ¤í…œ ì˜ì¡´
String key = fileName + "_" + file.lastModified();

// âŒ ì €ì¥ í›„ key ê°±ì‹  ì•ˆ í•¨
if (status == 2) {
    saveFile(fileName, inputStream);
}
```

### After (2í¸)

```java
// âœ… Service ê³„ì¸µ ë¶„ë¦¬
private final DocumentService documentService;

// âœ… DB ê¸°ë°˜ key ìƒì„±
String key = documentService.getEditorKey(fileName);
// â†’ KeyUtils.generateEditorKey(fileKey, editorVersion)

// âœ… ì €ì¥ í›„ ë²„ì „ ì¦ê°€
if (status == 2) {
    documentService.saveDocumentFromUrl(url, fileName);
    documentService.incrementEditorVersion(fileName);
}
```

---

## ğŸ“Š ë¹„êµí‘œ

| í•­ëª© | 1í¸ | 2í¸ |
|------|-----|-----|
| **Key ìƒì„±** | `fileName + lastModified` | `fileKey + "_v" + editorVersion` |
| **Key ê´€ë¦¬** | íŒŒì¼ì‹œìŠ¤í…œ ì˜ì¡´ | DB ê¸°ë°˜ ë²„ì „ ê´€ë¦¬ |
| **ì €ì¥ í›„ ì²˜ë¦¬** | ì—†ìŒ | editorVersion ì¦ê°€ |
| **ê³„ì¸µ ë¶„ë¦¬** | Controller â†’ Repository | Controller â†’ Service â†’ Repository |
| **Force Save** | êµ¬ë¶„ ì•ˆ í•¨ | version ìœ ì§€ (co-editing) |
| **Key ê²€ì¦** | ì—†ìŒ | KeyUtils (128ì, íŠ¹ìˆ˜ë¬¸ì) |

---

## ğŸ¤” 3í¸ ì˜ˆê³ 

### âš ï¸ í˜„ì¬ í•œê³„

```java
@Configuration
@Slf4j
public class MinioConfig {

    @Value("${minio.endpoint}")
    private String endpoint;

    @Value("${minio.accessKey}")
    private String accessKey;

    @Value("${minio.secretKey}")
    private String secretKey;

    @Bean
    public MinioClient minioClient() {
        log.info("Initializing MinIO client with endpoint: {}", endpoint);
        return MinioClient.builder()
                .endpoint(endpoint)
                .credentials(accessKey, secretKey)
                .build();
    }
}
```

### MinioStorageService.java

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MinioStorageService {

    private final MinioClient minioClient;

    @Value("${minio.bucket}")
    private String bucket;

    @Value("${minio.presigned-url-expiry}")
    private int presignedUrlExpiry;

    @PostConstruct
    public void init() {
        try {
            boolean found = minioClient.bucketExists(
                    BucketExistsArgs.builder().bucket(bucket).build()
            );

            if (!found) {
                minioClient.makeBucket(
                        MakeBucketArgs.builder().bucket(bucket).build()
                );
                log.info("MinIO bucket created: {}", bucket);
            } else {
                log.info("MinIO bucket already exists: {}", bucket);
            }
        } catch (Exception e) {
            throw new StorageException("Failed to initialize MinIO bucket", e);
        }
    }

    /**
     * íŒŒì¼ ì—…ë¡œë“œ (MultipartFile â†’ MinIO)
     */
    public String uploadFile(MultipartFile file, String objectName) {
        try (InputStream inputStream = file.getInputStream()) {
            minioClient.putObject(
                    PutObjectArgs.builder()
                            .bucket(bucket)
                            .object(objectName)
                            .stream(inputStream, file.getSize(), -1)
                            .contentType(file.getContentType())
                            .build()
            );
            log.info("File uploaded to MinIO: {}/{}", bucket, objectName);
            return objectName;
        } catch (Exception e) {
            throw new StorageException("Failed to upload file: " + objectName, e);
        }
    }

    /**
     * íŒŒì¼ ë‹¤ìš´ë¡œë“œ (MinIO â†’ InputStream)
     */
    public InputStream downloadFile(String objectName) {
        try {
            return minioClient.getObject(
                    GetObjectArgs.builder()
                            .bucket(bucket)
                            .object(objectName)
                            .build()
            );
        } catch (ErrorResponseException e) {
            if (e.errorResponse().code().equals("NoSuchKey")) {
                throw new StorageException("File not found: " + objectName);
            }
            throw new StorageException("Failed to download file: " + objectName, e);
        } catch (Exception e) {
            throw new StorageException("Failed to download file: " + objectName, e);
        }
    }

    /**
     * íŒŒì¼ ì‚­ì œ
     */
    public void deleteFile(String objectName) {
        try {
            minioClient.removeObject(
                    RemoveObjectArgs.builder()
                            .bucket(bucket)
                            .object(objectName)
                            .build()
            );
            log.info("File deleted from MinIO: {}/{}", bucket, objectName);
        } catch (Exception e) {
            throw new StorageException("Failed to delete file: " + objectName, e);
        }
    }

    /**
     * Presigned URL ìƒì„± (1ì‹œê°„ ìœ íš¨)
     */
    public String generatePresignedUrl(String objectName) {
        try {
            String url = minioClient.getPresignedObjectUrl(
                    GetPresignedObjectUrlArgs.builder()
                            .method(Method.GET)
                            .bucket(bucket)
                            .object(objectName)
                            .expiry(presignedUrlExpiry, TimeUnit.SECONDS)
                            .build()
            );
            log.debug("Generated presigned URL for {}, expiry: {} seconds",
                objectName, presignedUrlExpiry);
            return url;
        } catch (Exception e) {
            throw new StorageException("Failed to generate presigned URL: " + objectName, e);
        }
    }

    /**
     * ê°ì²´ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
     */
    public boolean objectExists(String objectName) {
        try {
            minioClient.statObject(
                    StatObjectArgs.builder()
                            .bucket(bucket)
                            .object(objectName)
                            .build()
            );
            return true;
        } catch (ErrorResponseException e) {
            if (e.errorResponse().code().equals("NoSuchKey")) {
                return false;
            }
            throw new StorageException("Failed to check object existence: " + objectName, e);
        } catch (Exception e) {
            throw new StorageException("Failed to check object existence: " + objectName, e);
        }
    }
}
```

### StorageException.java

```java
public class StorageException extends RuntimeException {
    public StorageException(String message) {
        super(message);
    }

    public StorageException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### application.yml (MinIO ì„¤ì • ì¶”ê°€)

```yaml
# MinIO Configuration
minio:
  endpoint: ${MINIO_ENDPOINT:http://localhost:9000}
  accessKey: ${MINIO_ROOT_USER:minioadmin}
  secretKey: ${MINIO_ROOT_PASSWORD:minioadmin_password}
  bucket: ${MINIO_BUCKET:onlyoffice-documents}
  presigned-url-expiry: 3600  # 1ì‹œê°„ (ì´ˆ)
```

### .env íŒŒì¼ ì—…ë°ì´íŠ¸

```env
# MinIO (ì´ì œ ì‹¤ì œ ì‚¬ìš©!)
MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=your-minio-password-here
MINIO_ENDPOINT=http://localhost:9000
MINIO_BUCKET=onlyoffice-documents
```

### í…ŒìŠ¤íŠ¸ ì‘ì„±

```java
@ExtendWith(MockitoExtension.class)
@DisplayName("MinioStorageService ë‹¨ìœ„ í…ŒìŠ¤íŠ¸")
class MinioStorageServiceTest {

    @Mock
    private MinioClient minioClient;

    @InjectMocks
    private MinioStorageService storageService;

    @Test
    @DisplayName("ë²„í‚·ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ìƒˆë¡œ ìƒì„±í•œë‹¤")
    void init_CreatesBucket_WhenNotExists() throws Exception {
        when(minioClient.bucketExists(any(BucketExistsArgs.class)))
            .thenReturn(false);

        storageService.init();

        verify(minioClient).bucketExists(any(BucketExistsArgs.class));
        verify(minioClient).makeBucket(any(MakeBucketArgs.class));
    }

    @Test
    @DisplayName("MultipartFileì„ MinIOì— ì—…ë¡œë“œí•  ìˆ˜ ìˆë‹¤")
    void uploadFile_Success() throws Exception {
        String objectName = "documents/test.docx";
        MultipartFile file = new MockMultipartFile(
            "file", "test.docx", "application/...", "content".getBytes()
        );

        ObjectWriteResponse mockResponse = mock(ObjectWriteResponse.class);
        when(minioClient.putObject(any(PutObjectArgs.class)))
            .thenReturn(mockResponse);

        String result = storageService.uploadFile(file, objectName);

        assertThat(result).isEqualTo(objectName);
        verify(minioClient).putObject(any(PutObjectArgs.class));
    }
}
```

### êµ¬í˜„ëœ ê¸°ëŠ¥ ìš”ì•½

| ë©”ì„œë“œ | ì„¤ëª… |
|--------|------|
| `init()` | ë²„í‚· ìë™ ìƒì„± (@PostConstruct) |
| `uploadFile()` | MultipartFile â†’ MinIO ì—…ë¡œë“œ |
| `downloadFile()` | MinIO â†’ InputStream ë‹¤ìš´ë¡œë“œ |
| `deleteFile()` | MinIO ê°ì²´ ì‚­ì œ |
| `generatePresignedUrl()` | 1ì‹œê°„ ìœ íš¨ ì„ì‹œ URL ìƒì„± |
| `objectExists()` | íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ |

### í…ŒìŠ¤íŠ¸ ê²°ê³¼

```bash
./gradlew test --tests MinioStorageServiceTest

âœ… 13ê°œ í…ŒìŠ¤íŠ¸ ëª¨ë‘ í†µê³¼
- ë²„í‚· ì´ˆê¸°í™” (3ê°œ)
- íŒŒì¼ ì—…ë¡œë“œ (2ê°œ)
- íŒŒì¼ ë‹¤ìš´ë¡œë“œ (2ê°œ)
- íŒŒì¼ ì‚­ì œ (2ê°œ)
- Presigned URL ìƒì„± (2ê°œ)
- ê°ì²´ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ (2ê°œ)
```

### 2í¸ê³¼ 3í¸ì˜ ê°€êµ

**2í¸ ì™„ì„± ë‚´ìš©**:
- âœ… DB ê¸°ë°˜ document.key ê´€ë¦¬
- âœ… editorVersionìœ¼ë¡œ ë²„ì „ ì¶”ì 
- âœ… KeyUtilsë¡œ key ìƒì„±/ê²€ì¦
- âœ… ê³„ì¸µ ë¶„ë¦¬ (Controller â†’ Service â†’ Repository)
- âœ… **MinIO Storage Service êµ¬í˜„** â† NEW!

**3í¸ì—ì„œ í•  ì¼**:
- DocumentServiceê°€ MinioStorageService ì‚¬ìš©
- FileControllerë¥¼ Presigned URL ê¸°ë°˜ìœ¼ë¡œ ì „í™˜
- íŒŒì¼ ì—…ë¡œë“œ API + DB í†µí•©
- Saga íŒ¨í„´ìœ¼ë¡œ íŠ¸ëœì­ì…˜ ë³´ì¥

---

## ğŸ¤” 3í¸ ì˜ˆê³ 

### âš ï¸ í˜„ì¬ í•œê³„

1. ~~**íŒŒì¼ ì €ì¥ì†Œ**: ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œ (MinIO ë¯¸ì‚¬ìš©)~~ â† **MinioStorageServiceë¡œ í•´ê²°**
2. **ë¬¸ì„œ ìƒì„±**: ìˆ˜ë™ INSERT (ì—…ë¡œë“œ API ì—†ìŒ)
3. **ë³´ì•ˆ**: íŒŒì¼ ê²€ì¦ ì—†ìŒ
4. **íŠ¸ëœì­ì…˜**: DB â†” MinIO ì›ìì„± ë³´ì¥ ì•ˆ ë¨
5. **í†µí•©**: DocumentServiceê°€ ì•„ì§ MinIO ë¯¸ì‚¬ìš©

### 3í¸ì—ì„œ ì¶”ê°€í•  ê²ƒ

âœ… **MinIO ì™„ì „ í†µí•©**: DocumentService + MinioStorageService ì—°ê²°
âœ… **Document Upload API**: íŒŒì¼ ì—…ë¡œë“œ â†’ DB + MinIO (ì›ìì )
âœ… **Apache Tika**: íŒŒì¼ ê²€ì¦ (ë§¤ì§ ë°”ì´íŠ¸, MIME)
âœ… **Saga íŒ¨í„´**: ë¶„ì‚° íŠ¸ëœì­ì…˜ ì›ìì„± ë³´ì¥
âœ… **Presigned URL ê¸°ë°˜ íŒŒì¼ ì„œë¹™**: FileController ì „í™˜
âœ… **Next.js UI**: ë¬¸ì„œ ëª©ë¡ + ì—ë””í„° í˜ì´ì§€

---

## ğŸ“ ì •ë¦¬

### 2í¸ì—ì„œ ë°°ìš´ í•µì‹¬

1. **document.key ìŠ¤í™ ì´í•´**: í¸ì§‘ ì„¸ì…˜ vs íŒŒì¼ ì˜êµ¬ ID
2. **DB ê¸°ë°˜ ë²„ì „ ê´€ë¦¬**: editorVersion í•„ë“œë¡œ ì¶”ì 
3. **KeyUtils ìœ í‹¸ë¦¬í‹°**: 128ì ì œí•œ, íŠ¹ìˆ˜ë¬¸ì ì œê±°, í•´ì‹œ ì¶•ì•½
4. **ê³„ì¸µ ë¶„ë¦¬**: ControllerëŠ” HTTPë§Œ, Serviceê°€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
5. **Force Save ì²˜ë¦¬**: co-editing ì„¸ì…˜ ìœ ì§€ (version ì¦ê°€ ì•ˆ í•¨)

### ì‹¤ì œ ì½”ë“œ ìœ„ì¹˜

**Document.key ê´€ë¦¬**:
- `Document.java` - editorVersion í•„ë“œ, getEditorKey()
- `DocumentRepository.java` - findByFileNameAndDeletedAtIsNull()
- `KeyUtils.java` - key ìƒì„±/ê²€ì¦
- `DocumentService.java` - getEditorKey(), incrementEditorVersion()
- `EditorController.java` - Service ì‚¬ìš©
- `CallbackController.java` - statusë³„ ë¶„ê¸° ì²˜ë¦¬

**MinIO Storage** (v2.0):
- `MinioConfig.java` - MinioClient Bean ì„¤ì •
- `MinioStorageService.java` - íŒŒì¼ ì—…ë¡œë“œ/ë‹¤ìš´ë¡œë“œ/ì‚­ì œ/Presigned URL
- `StorageException.java` - ìŠ¤í† ë¦¬ì§€ ì˜ˆì™¸ ì²˜ë¦¬
- `MinioStorageServiceTest.java` - 13ê°œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

---

## ğŸ“š ì°¸ê³  ìë£Œ

- [OnlyOffice document.key ê³µì‹ ë¬¸ì„œ](https://api.onlyoffice.com/docs/docs-api/usage-api/config/document/document/#key)
- [OnlyOffice Callback Handler](https://api.onlyoffice.com/docs/docs-api/usage-api/callback-handler/)
- [í”„ë¡œì íŠ¸ í†µí•© ê°€ì´ë“œ](docs/onlyoffice-integration-guide.md)

**GitHub**: [onlyoffice-demo](https://github.com/taez224/onlyoffice-demo)

**ê´€ë ¨ PR**:
- [#24 OnlyOffice document.key ê´€ë¦¬ ë¡œì§ ê°œì„ ](https://github.com/taez224/onlyoffice-demo/pull/24)
- [#25 MinIO Storage Service êµ¬í˜„](https://github.com/taez224/onlyoffice-demo/pull/25)